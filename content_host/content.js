require("dotenv").config();
const ethers = require("ethers");
const lighthouse = require('@lighthouse-web3/sdk');

const cid = "QmY9Q95z6mJA1DTeULHS4vwNMYe8rHwwWTcBD76oYQvFJh";

const signAuthMessage = async(publicKey, privateKey) =>{
  const provider = new ethers.providers.JsonRpcProvider();
  const signer = new ethers.Wallet(privateKey, provider);
  const messageRequested = (await lighthouse.getAuthMessage(publicKey)).data.message;
  const signedMessage = await signer.signMessage(messageRequested);
  return(signedMessage)
}

const accessControl = async() =>{
  try{
    // CID on which you are applying encryption
    // CID is generated by uploading a file with encryption
    // Only the owner of file can apply access conditions
    const publicKey = "0x5AdA39e766c416CA083d8c7e43104f2C7cF2194A";
    const privateKey = process.env.PRIVATE_KEY_WALLET;
    
    // Conditions to add
    const conditions = [
      {
        id: 1,
        chain: "Optimism",
        method: "getBlockNumber",
        standardContractType: "",
        returnValueTest: {
          comparator: ">=",
          value: "13349"
        },
      },
    ];

    // Aggregator is what kind of operation to apply to access conditions
    // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
    const aggregator = "([1])";

    const signedMessage = await signAuthMessage(publicKey, privateKey);
    /*
      accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
        Parameters:
          publicKey: owners public key
          CID: CID of file to decrypt
          signedMessage: message signed by owner of publicKey
          conditions: should be in format like above
          aggregator: aggregator to apply on conditions
    */
    const response = await lighthouse.accessCondition(
      publicKey,
      cid,
      signedMessage,
      conditions,
      aggregator
    );

    // // Display response
    console.log(response);
    /*
      {
        data: {
          cid: 'Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7',
          status: 'Success'
        }
      }
    */
  } catch(error){
    console.log(error)
  }
}

const getfileEncryptionKey = async() => {
  try{
    // Get key back after passing access control condition
    const publicKey = "0x5AdA39e766c416CA083d8c7e43104f2C7cF2194A";
    const privateKey = process.env.PRIVATE_KEY_WALLET;

    const signedMessage = await signAuthMessage(publicKey, privateKey);
    /*
      fetchEncryptionKey(cid, publicKey, signedMessage)
        Parameters:
          cid: cid of file
          publicKey: your public key
          signedMessage: message signed by owner of public key
    */
    const key = await lighthouse.fetchEncryptionKey(
      cid,
      publicKey,
      signedMessage
    );
    console.log(key);
    /*
      {
        data: {
          key: '18475nf54a37294f538t4c83ba67e0c5e11fds0fcaa2507cg8539aaff79c5d82'
        }
      }
    */
  } catch(error){
    console.log(error)
  }
}

accessControl()

//CID: QmY9Q95z6mJA1DTeULHS4vwNMYe8rHwwWTcBD76oYQvFJh
//pubkey: 0x5AdA39e766c416CA083d8c7e43104f2C7cF2194A
//Api Key: cf018bda-27d0-4083-8119-6c3b3a95ac01